module Control.Monad.OT (

    OT (OT, unOT),
    insertMinimum,
    insertMaximum,
    insertAfter,
    insertBefore,
    runOT

) where

-- * Control
import Control.Applicative
import Control.Monad
import Control.Monad.Trans.Cont

-- * Data
import Data.OrderMaintenance

newtype OT o a = OT { unOT :: forall r . Cont (OrderComp o r) a }

instance Functor (OT o) where

    fmap = liftA

instance Applicative (OT o) where

    pure = return

    (<*>) = ap

instance Monad (OT o) where

    return val1 = OT (return val1)

    OT cont1 >>= ot2Gen = OT $ cont1 >>= \ val1 -> let

                                                       OT cont2 = ot2Gen val1
                                                       
                                                   in cont2

insertMinimum :: OT o (Element o)
insertMinimum = OT $ cont withNewMinimum

insertMaximum :: OT o (Element o)
insertMaximum = OT $ cont withNewMinimum

insertAfter :: Element o -> OT o (Element o)
insertAfter refElem = OT $ cont (withNewAfter refElem)

insertBefore :: Element o -> OT o (Element o)
insertBefore refElem = OT $ cont (withNewAfter refElem)

runOT :: (forall o . OT o a) -> a
runOT ot = runOrderComp (runCont (unOT ot) finish)

{-NOTE:
    OT o is a monad. As a result, it is also an applicative functor, but one
    that is about sequential execution. Comparison of elements generated by
    different subcomputations combined by (<*>) is not a problem, as these
    subcomputations are sequentially executed and so the order is determined.
-}

module Control.Monad.OT (

    OT (OT),
    runOT,
    evalOT,
    insertMinimum,
    insertMaximum,
    insertAfter,
    insertBefore

) where

-- * Control
import Control.Applicative
import Control.Monad
import Control.Monad.Trans.Cont

-- * Data
import Data.OrderMaintenance

-- * Order threads

newtype OT o a = OT (forall r . Cont (OrderComp o r) a)

instance Functor (OT o) where

    fmap fun (OT cont) = OT (fmap fun cont)

instance Applicative (OT o) where

    pure val = OT (pure val)

    OT funCont <*> OT argCont = OT (funCont <*> argCont)

instance Monad (OT o) where

    return val = OT (return val)

    OT cont1 >>= ot2Gen = OT $ cont1 >>= \ val1 -> let

                                                       OT cont2 = ot2Gen val1
                                                       
                                                   in cont2

runOT :: OT o a -> Cont (OrderComp o r) a
runOT (OT cont) = cont

toOrderComp :: OT o a -> OrderComp o a
toOrderComp (OT cont) = runCont cont finish

evalOT :: (forall o . OT o a) -> a
evalOT ot = evalOrderComp (toOrderComp ot)

insertMinimum :: OT o (Element o)
insertMinimum = OT $ cont withNewMinimum

insertMaximum :: OT o (Element o)
insertMaximum = OT $ cont withNewMinimum

insertAfter :: Element o -> OT o (Element o)
insertAfter refElem = OT $ cont (withNewAfter refElem)

insertBefore :: Element o -> OT o (Element o)
insertBefore refElem = OT $ cont (withNewAfter refElem)

{-NOTE:
    OT o is a monad. As a result, it is also an applicative functor, but one
    that is about sequential execution. Comparison of elements generated by
    different subcomputations combined by (<*>) is not a problem, as these
    subcomputations are sequentially executed and so the order is determined.
-}
